(load "../inc/src/tests-driver.scm")

(define (emit-program fxn)
  (emit "  .text")
  (emit "  .p2align 4,,15")
  (emit "  .globl  scheme_entry")
  (emit "  .type scheme_entry, @function")
  (emit "scheme_entry:")
  (emit ".LFB0:")
  (emit "  .cfi_startproc")
  (compile-program fxn)
  (emit "  .cfi_endproc")
  (emit ".LFE0:")
  (emit "  .size scheme_entry, .-scheme_entry")
)

(define fixnum-shift 2)
(define fixnum-mask #b11) ; do I know what I'm doing here?
(define fixnum-tag  #b00) 
(define empty-list    #b00101111)
(define bool-mask     #b1111111)
(define bool-tag      #b0011111)
(define bool-t        #b10011111)
(define bool-f        #b00011111)
(define char-mask     #b11111111)
(define char-tag      #b00001111)
(define char-shift    8)
(define wordsize      4) ; this might actually be 8 on x64, but it might not matter

(define (immediate-rep x)
  (cond
    ((integer? x) (ash x fixnum-shift))
    ((equal? '() x) empty-list) ; equivalently, (null? x)
    ((equal? #t x) bool-t)
    ((equal? #f x) bool-f)
    ((char? x) (bitwise-ior (ash (char->integer x) char-shift) char-tag))
  )
)

(define (compile-program x)
  (emit-expr x (* -1 wordsize)) ; -4 is our initial stack pointer/index
  (emit "  ret")
)

(define (immediate? x)
  (or (integer? x) (null? x) (boolean? x) (char? x))
)

(define (primcall-op x)
  (car x)
)

(define (primcall-operand1 x)
  (car (cdr x))
)

(define (primcall-operand2 x)
  (car (cdr (cdr x)))
)

(define (primcall? x)
;  (and  (pair? x) ; not any more
        (member (car x)
          '(  add1
              sub1
              char->integer
              integer->char
              zero?
              null?
              not
              char?
              integer?
              boolean?
              +
              -
              *
           )
        )
;  )
)

(define (emit-primitive-call x si) ; maintain the stack index
  (case (primcall-op x)
    ((add1)
      (emit-expr (primcall-operand1 x) si)  ;; aren't we potentially clobbering computations
                                         ;; lower down the stack here?
      (emit "  addl $~s, %eax" (immediate-rep 1))
    )
    ((sub1)
      (emit-expr (primcall-operand1 x) si)
      (emit "  subl $~s, %eax" (immediate-rep 1))
    )
    ((char->integer)
      (emit-expr (primcall-operand1 x) si)
      (emit "  shr $~s, %eax" 6)
    )
    ((integer->char)
      (emit-expr (primcall-operand1 x) si)
      (emit "  shl $~s, %eax" 6) ; char-shift - fixnum-shift
      (emit "  or $~s, %eax" char-tag)
    )
    ((zero?)
      (emit-expr (primcall-operand1 x) si)
      (emit "  cmpl $0, %eax")
      (emit "  movl $0, %eax")
      (emit "  sete %al") ; conditional setting of byte to 1 based on the earlier cmpl
      (emit "  sall $7, %eax")
      (emit "  orl $31, %eax")
    )
    ((null?)
      (emit-expr (primcall-operand1 x) si)
      (emit "  cmpl $~s, %eax" empty-list)
      (emit "  movl $0, %eax")
      (emit "  sete %al") ; conditional setting of byte to 1 based on the earlier cmpl
      (emit "  sall $7, %eax")
      (emit "  orl $31, %eax")
    )
    ((char?)
      (emit-expr (primcall-operand1 x) si)
      (emit "  andl $~s, %eax" char-mask)
      (emit "  cmpl $~s, %eax" char-tag)
      (emit "  movl $0, %eax")
      (emit "  sete %al")
      (emit "  sall $7, %eax")
      (emit "  orl $31, %eax")
    )
    ((integer?)
      (emit-expr (primcall-operand1 x) si)
      (emit "  andl $~s, %eax" fixnum-mask)
      (emit "  cmpl $~s, %eax" fixnum-tag)
      (emit "  movl $0, %eax")
      (emit "  sete %al")
      (emit "  sall $7, %eax")
      (emit "  orl $31, %eax")
    )
    ((boolean?)
      (emit-expr (primcall-operand1 x) si)
      (emit "  andl $~s, %eax" bool-mask)
      (emit "  cmpl $~s, %eax" bool-tag)
      (emit "  movl $0, %eax")
      (emit "  sete %al")
      (emit "  sall $7, %eax")
      (emit "  orl $31, %eax")
    )
    ((+) ; check for correct type?
      (emit-expr (primcall-operand1 x) si)
      (emit "  movl %eax, ~s(%rsp)" si)
      (emit-expr
        (primcall-operand2 x)
        (- si wordsize) ; going down/up the stack (depending on how you look at it)
      )
      (emit "  addl ~s(%rsp), %eax" si)
    )
    ((-)
      (emit-expr (primcall-operand2 x) si)
      (emit "  movl %eax, ~s(%rsp)" si)
      (emit-expr
        (primcall-operand1 x)
        (- si wordsize)
      )
      (emit "  subl ~s(%rsp), %eax" si)
    )
    ((*)
      (emit-expr (primcall-operand1 x) si)
      (emit "  movl %eax, ~s(%rsp)" si)
      (emit-expr
        (primcall-operand2 x)
        (- si wordsize)
      )
      (emit "  shr $~s, %eax" fixnum-shift) ; when we multiply we have to remove the shift factor from one of the numbers, otherwise it gets doubled and our answer is *4
      (emit "  imull ~s(%rsp), %eax" si)
    )
  )
)

(define (emit-expr x si) ; also need to maintain the stack index here
  (cond
    ((immediate? x)
      (emit "  movl $~s, %eax" (immediate-rep x))
    )
    ((primcall? x)
      (emit-primitive-call x si)
    )
    (else
      (raise "ran out of expression types")
    )
  )
)

(define (run-compile-clf expr)
  (let ([p (open-output-file "clf.s" 'replace)])
    (parameterize ([compile-port p])
      (emit-program expr)
    )
    (close-output-port p)
  )
)

(run-compile-clf '(+ 1000 (* -1 (* 2 (+ 7 20)))))
;(run-compile-clf '(- 1 20))
;(run-compile-clf '(+ 1 (+ 2 20)))
;(run-compile-clf '(boolean? #f))
;(run-compile-clf '(integer? ()))
;(run-compile-clf '(char? #\l))
;(run-compile-clf '(null? 2))
;(run-compile-clf '(zero? 0))
;(run-compile-clf '(char->integer #\k))
;(run-compile-clf '(add1 3))
;(run-compile-clf '(sub1 3))
;(run-compile-clf 4)

