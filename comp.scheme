(load "../inc/src/tests-driver.scm")

(define (emit-program fxn)
  (emit "  .text")
  (emit "  .p2align 4,,15")
  (emit "  .globl  scheme_entry")
  (emit "  .type scheme_entry, @function")
  (emit "scheme_entry:")
  (emit ".LFB0:")
  (emit "  .cfi_startproc")
  (compile-program fxn)
  (emit "  .cfi_endproc")
  (emit ".LFE0:")
  (emit "  .size scheme_entry, .-scheme_entry")
)

(define fixnum-shift 2)
(define fixnum-mask #b11) ; do I know what I'm doing here?
(define fixnum-tag  #b00) 
(define empty-list    #b00101111)
(define bool-mask     #b1111111)
(define bool-tag      #b0011111)
(define bool-t        #b10011111)
(define bool-f        #b00011111)
(define char-mask     #b11111111)
(define char-tag      #b00001111)
(define char-shift    8)

(define (immediate-rep x)
  (cond
    ((integer? x) (ash x fixnum-shift))
    ((equal? '() x) empty-list) ; equivalently, (null? x)
    ((equal? #t x) bool-t)
    ((equal? #f x) bool-f)
    ((char? x) (bitwise-ior (ash (char->integer x) char-shift) char-tag))
  )
)

(define (compile-program x)
  (emit-expr x)
  (emit "  ret")
)

(define (immediate? x)
  (or (integer? x) (null? x) (boolean? x) (char? x))
)

(define (primcall-op x)
  (car x)
)

(define (primcall-operand1 x)
  (car (cdr x))
)

(define (primcall-operand2 x)
  (car (cdr (cdr x)))
)

(define (primcall? x)
;  (and  (pair? x) ; not any more
        (member (car x)
          '(  add1
              sub1
              char->integer
              integer->char
              zero?
              null?
              not
              char?
              integer?
              boolean?
              +
              -
              *
           )
        )
;  )
)

(define (emit-expr x)
  (cond
    ((immediate? x)
      (emit "  movl $~s, %eax" (immediate-rep x)))
    ((primcall? x)
      (case (primcall-op x)
        ((add1)
          (emit-expr (primcall-operand1 x))
          (emit "  addl $~s, %eax" (immediate-rep 1))
        )
        ((sub1)
          (emit-expr (primcall-operand1 x))
          (emit "  subl $~s, %eax" (immediate-rep 1))
        )
        ((char->integer)
          (emit-expr (primcall-operand1 x))
          (emit "  shr $~s, %eax" 6)
        )
        ((integer->char)
          (emit-expr (primcall-operand1 x))
          (emit "  shl $~s, %eax" 6) ; char-shift - fixnum-shift
          (emit "  or $~s, %eax" char-tag)
        )
        ((zero?)
          (emit-expr (primcall-operand1 x))
          (emit "  cmpl $0, %eax")
          (emit "  movl $0, %eax")
          (emit "  sete %al") ; conditional setting of byte to 1 based on the earlier cmpl
          (emit "  sall $7, %eax")
          (emit "  orl $31, %eax")
        )
        ((null?)
          (emit-expr (primcall-operand1 x))
          (emit "  cmpl $~s, %eax" empty-list)
          (emit "  movl $0, %eax")
          (emit "  sete %al") ; conditional setting of byte to 1 based on the earlier cmpl
          (emit "  sall $7, %eax")
          (emit "  orl $31, %eax")
        )
        ((char?)
          (emit-expr (primcall-operand1 x))
          (emit "  andl $~s, %eax" char-mask)
          (emit "  cmpl $~s, %eax" char-tag)
          (emit "  movl $0, %eax")
          (emit "  sete %al")
          (emit "  sall $7, %eax")
          (emit "  orl $31, %eax")
        )
        ((integer?)
          (emit-expr (primcall-operand1 x))
          (emit "  andl $~s, %eax" fixnum-mask)
          (emit "  cmpl $~s, %eax" fixnum-tag)
          (emit "  movl $0, %eax")
          (emit "  sete %al")
          (emit "  sall $7, %eax")
          (emit "  orl $31, %eax")
        )
        ((boolean?)
          (emit-expr (primcall-operand1 x))
          (emit "  andl $~s, %eax" bool-mask)
          (emit "  cmpl $~s, %eax" bool-tag)
          (emit "  movl $0, %eax")
          (emit "  sete %al")
          (emit "  sall $7, %eax")
          (emit "  orl $31, %eax")
        )
        ((+) ; check for correct type?
          (emit-expr (primcall-operand1 x))
          (emit "  movl %eax, ~s(%rsp)" -4)
          (emit-expr (primcall-operand2 x))
          (emit "  addl ~s(%rsp), %eax" -4)
        )
        ((-)
          (emit-expr (primcall-operand2 x))
          (emit "  movl %eax, ~s(%rsp)" -4)
          (emit-expr (primcall-operand1 x))
          (emit "  subl ~s(%rsp), %eax" -4)
        )
        ((*)
          (emit-expr (primcall-operand1 x))
          (emit "  movl %eax, ~s(%rsp)" -4)
          (emit-expr (primcall-operand2 x))
          (emit "  shr $~s, %eax" fixnum-shift) ; when we multiply we have to remove the shift factor from one of the numbers, otherwise it gets doubled and our answer is *4
          (emit "  imull ~s(%rsp), %eax" -4)
        )
      )
    )
    (else
      (raise "ran out of expression types")
    )
  )
)

(define (run-compile-clf expr)
  (let ([p (open-output-file "clf.s" 'replace)])
    (parameterize ([compile-port p])
      (emit-program expr)
    )
    (close-output-port p)
  )
)

(run-compile-clf '(* 7 20))
;(run-compile-clf '(- 1 20))
;(run-compile-clf '(+ 1 20))
;(run-compile-clf '(boolean? #f))
;(run-compile-clf '(integer? ()))
;(run-compile-clf '(char? #\l))
;(run-compile-clf '(null? 2))
;(run-compile-clf '(zero? 0))
;(run-compile-clf '(char->integer #\k))
;(run-compile-clf 4)

